/**
 * 泛型程序设计
 * 
 * 为什么要使用范型程序设计
 * 	类型参数的好处
 * 	谁想成为范型程序员
 * 定义简单范型类
 * 范型方法
 * 类型变量的限定
 * 范型代码和虚拟机
 * 	类型擦除
 * 	翻译泛型表达式
 * 	调用遗留代码
 * 约束和限制性
 * 	不能用基本类型实例化类型参数
 * 	运行时类型查询只适用于原始类型
 * 	不能创建参数化类型的数组
 * 	Varargs警告
 * 	不能实例化类型变量
 * 	不能构造泛型数组
 * 	泛型类的静态上下文中类型变量无效
 * 	不能抛出或捕获泛型类的实例
 * 	可以消除对受查异常的检查(?)
 * 	注意擦除后的冲突
 * 范型类型的继承规则：使用通配符解决
 * 通配符类型
 * 	通配符概念：安全的访问器方法和不安全的更改器方法。
 * 	通配符的超类型限定
 * 	无限定通配符
 * 	通配符捕获
 * 反射和范型
 * 	泛型class类
 * 	使用Class<T>参数进行类型匹配
 * 	虚拟机中的泛型类型信息
 * @author niuzhihuan
 */
package v1.ch08;